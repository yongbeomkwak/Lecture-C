# Compile


### 컴파일러란?
```c
#include <stdio.h>

int main() {

    printf("Hello") 
}

```

위 코드를 컴퓨터는 어떻게 이해하고 실행하는걸까요 ??<br>
컴퓨터는 0과 1밖에 모르는 생각보다 순수한(?) 친구입니다. 

컴파일러는 고급 프로그래밍 언어를 실행 프로그램으로 만들기 위해 저급 프로그래밍 언어(예, 어셈블리 언어, object 코드, 기계어)로 바꾸는 역할을 합니다.

우리 수업은 gcc라는 컴파일러를 사용할겁니다. 

<br>

## GCC란?

GCC는 GNU 컴파일러 모음 (GNU Compiler Collection)의 약자이다. GNU 프로젝트의 일환으로 개발되어 널리 쓰이고 있는 컴파일러이다.

## GNU란?

과거에 소프트웨어를 판매자들은 사용자위에 군림하고 통제하는 성향이 있었습니다.

리처드 스톨먼 이런 식으로 사용자간의 결속이 깨지는 것을 거부했고 비공개 협정이나 소프트웨어 라이센스 협약에 동참하지 않았습니다.


GNU는 GNU’s not UNIX 의 재귀약자로, 리처드 스톨먼이 각종 자유 소프트웨어들이 돌아가고 번영할 수 있는 기반 생태계를 구축하기 위해 시작한 프로젝트 입니다.


GUN 는 저작권이 인정되는(not public domain) 소프트웨어다. <br>
누구나 GNU를 개발하고 배포할 수 있지만 어떤 이도  GNU가 보다 **널리 배포되는 것을 제한할 수 없다**. <br><br>
즉, 변경한 내용을 독점할 수 없다는 것이다.

<br>

## 소스 코드가 실행 파일이 되는 과정

소스 코드를 실행 파일로 만들기 위해 네 가지 단계를 거친다.

### 1. 전처리 단계

- #include : 지정된 특정 파일의 내용을 해당 지시자가 있는 위치에 삽입
- #define : 매크로 함수 및 상수 정의에 사용한다. 코드 내의 해당 상수를 프로그래머가 정의한 문자열로 대체한다.

 즉, 필요한 헤더 파일을 삽입하고 실행 문장의 매크로를 상수로 변환한다. 소스 파일 file.c가 전처리기를 거치면 file.i라는 이름의 파일이 생성되지만 디스크에는 저장되지 않는다.

```shell
# 전처리 과정 실행
# -E (file.c) : 전처리를 실행하고 , 컴파일을 중단한다.
# -o : 앞의 처리되 결과를 이름이 file.i 파일안에 넣는다.
gcc -E file.c -o file.i
```

### 2. 컴파일 단계

컴파일러가 전처리된 파일(file.i)로부터 **어셈블리어**로 된 파일(file.s)을 생성한다. 그런데 일반적으로 다음 단계인 어셈블 단계를 바로 실행하므로 file.s 파일은 디스크에 저장되지 않는다.

>어셈블리어란?

> 기계어보다 한 단계 위에 있는 언어이며 기계어와 함께 단 두 가지 뿐인 저급 언어에 속한다. 
>
> 기계어는 컴퓨터 관점에서 바로 읽을 수 있지만, 인간이 사용하기 불편한 언어이기 때문에 이를 보완하기 위해 등장한 것이 어셈블리어이다. 

```shell
# 컴파일 과정 실행
# -S (file.i) : 어셈블리어로 변환
# -o : 앞의 처리되 결과를 이름이 file.s 파일안에 넣는다.
gcc -S file.i -o file.s
```

### 3. 어셈블 단계

어셈블리어 파일 file.s 를 기계어로 된 오브젝트 파일 file.o 파일로 변환한다. 즉, 컴퓨터가 읽을 수 있는 0과 1로 이루어진 2진수 코드로 변환하는 것이다.

```shell
# 컴파일 과정 실행
# -c (file.s) : 어셈블리어를 기계어로 변환
# -o : 앞의 처리되 결과를 이름이 file.o 파일안에 넣는다.
gcc -S file.s -o file.o
```

### 4. 링크 단계

링크 단계는 작성한 프로그램이 사용하는 다른 프로그램이나 라이브러리를 가져와서 연결하는 과정이다. 그 결과로 실행 가능한 파일을 생성한다. 

```shell
# 컴파일 과정 실행
# -o (file.s) : 실행파일 abc.out을 생선
gcc main.o -o abc
```

```shell
# -I 옵션 기능 : 표준 디렉토리가 아닌 위치에 있는 헤더 파일의 디렉토리를 지정한다. 
# $ gcc 소스파일이름 -I디렉토리 이름

gcc main.o -o abc
```


### 컴파일 옵션 

```
-o [파일명] [*.c] : 지정한 파일명으로 실행 파일을 저장한다.
	ex) gcc -o result.out main.c

-E : 전처리 단계를 수행한 후, 컴파일 과정을 거치지 않는다.
    실행 결과는 standard output에 출력된다.

-S : 컴파일 단계를 수행한 후, 어셈블 과정을 거치지 않는다. 
	실행 결과로 어셈블리어로 변환된 *.s 파일이 생성된다.

-c [파일명] [*.c] : 소스 코드를 컴파일 또는 어셈블하며, 링크를 하지 않는다.  파일명으로 오브젝트 파일을 생성한다.
    ex) gcc -c ft_isalnum.c

-I [디렉토리명] : 디렉토리명에서 헤더 파일을 검색한다.
    ex) gcc 소스파일이름 -I디렉토리 이름

-l [라이브러리] : 라이브러리 파일과 링크한다. 접미사나 확장자(.a/.o)가 없어도 링크한다.
    ex) gcc 소스파일이름 -l라이브러리이름
    ex2) 라이브러리 파일이 libmath.a 일때 다음과 같이 작성 gcc myfile.c -lmath -o myfile

-L [디렉토리명] : 디렉토리 내에서 라이브러리 파일을 찾는다.
    ex) gcc 소스파일이름 -L라이브러리위치

-D [매크로상수명]=[값] : 매크로 상수를 정의하기 위한 옵션이다.
	ex) gcc -D BUFFER_SIZE=42 : BUFFER_SIZE 라는 매크로 상수의 값을 42로 설정한다.

```